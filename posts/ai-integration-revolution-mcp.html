<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The AI Integration Revolution is Here: Meet MCP</title>
    <link rel="stylesheet" href="../css/posts.css">

</head>

<body>

    <div id="reading-progress"></div>

    <div class="container">
        <!-- Navigation Bar -->
        <nav class="top-nav">
            <a href="../index.html" class="back-link">Back to Blog</a>
            <span class="blog-logo">Thaer M Barakat</span>
        </nav>
        <header>
            <h1>The AI Integration Revolution is Here:<br><span style="white-space: nowrap;">Meet MCP...</span></h1>
            <h3 class="subtitle">How the Model Context Protocol is transforming AI assistant integration</h3>
            <p class="author">By Thaer M Barakat</p>
            <div class="meta-info">
                <span class="meta-item">üìÖ November 2025</span>
                <span class="meta-item">‚è±Ô∏è 10 min read</span>
                <span class="meta-item">üè∑Ô∏è AI Integration</span>
            </div>
        </header>
        </header>

        <article>
            <p>
                AI assistants are everywhere‚Äîbut they're isolated. Each one lives in its own bubble, unable to access
                your data, your tools, or your workflows. The Model Context Protocol (MCP) changes this fundamentally.
            </p>

            <p>
                Think of MCP as USB-C for AI. Just as USB-C created a universal standard for connecting devices,
                MCP creates a universal standard for connecting AI assistants to data sources and tools. One protocol,
                infinite possibilities.
            </p>

            <blockquote>
                MCP is not just another API‚Äîit's a fundamental shift in how AI assistants interact with the world.
            </blockquote>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number">100+</div>
                    <div class="stat-label">MCP Servers Available</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">Open</div>
                    <div class="stat-label">Source Protocol</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">Any</div>
                    <div class="stat-label">Data Source Compatible</div>
                </div>
            </div>

            <hr />

            <h2>The Integration Problem</h2>

            <p>
                Modern AI assistants are remarkably capable‚Äîuntil they need to interact with your actual work
                environment. Want your AI to access your company's database? Custom integration. Need it to read
                your Google Drive? Another custom integration. Want it to control your development tools? Yet
                another custom integration.
            </p>

            <div class="image-container">
                <img src="../images/mcp-integration-complexity.webp" alt="Integration complexity">
                <p class="image-caption">Every new integration requires custom development and maintenance
                </p>
            </div>

            <p>
                This creates a combinatorial explosion. With N AI assistants and M data sources, you potentially
                need N √ó M integrations. Each integration requires:
            </p>

            <ul>
                <li>Custom authentication logic</li>
                <li>Unique API client implementation</li>
                <li>Data transformation code</li>
                <li>Error handling and retry logic</li>
                <li>Ongoing maintenance as APIs change</li>
            </ul>

            <p>
                MCP solves this by creating a standard protocol. Build one MCP server for your data source, and
                every MCP-compatible AI assistant can use it immediately.
            </p>

            <div class="info-box">
                <h4>üí° The Power of Standards</h4>
                <p>Standards don't just reduce duplication‚Äîthey enable ecosystems. HTTP didn't just make web
                    development easier; it made the web possible. MCP does the same for AI integration.</p>
            </div>

            <hr />

            <h2>What is the Model Context Protocol?</h2>

            <p>
                The Model Context Protocol is an open standard that defines how AI assistants communicate with
                external data sources and tools. It was created by Anthropic and released as an open-source
                specification.
            </p>

            <p>
                MCP operates on a client-server architecture:
            </p>

            <ul class="agent-list">
                <li>
                    <strong>MCP Clients:</strong> AI applications (like Claude, IDEs, or custom tools) that want
                    to access external resources
                </li>
                <li>
                    <strong>MCP Servers:</strong> Lightweight programs that expose specific data sources or tools
                    through a standardized interface
                </li>
                <li>
                    <strong>MCP Protocol:</strong> The communication standard that allows clients and servers to
                    understand each other
                </li>
            </ul>

            <div class="image-container">
                <img src="../images/mcp-architecture-diagram.webp"
                    alt="MCP architecture diagram showing client-server communication"
                    style="width: 100%; height: 400px; object-fit: cover;" />
                <p class="image-caption">MCP creates a clean separation between AI clients and data sources</p>
            </div>

            <p>
                The protocol defines three core primitives:
            </p>

            <ul>
                <li><strong>Resources:</strong> Data that AI can read (files, database records, API responses)</li>
                <li><strong>Prompts:</strong> Templated conversations or instructions for specific tasks</li>
                <li><strong>Tools:</strong> Functions that AI can execute (run queries, send emails, create
                    tickets)</li>
            </ul>

            <hr />

            <h2>How MCP Works in Practice</h2>

            <p>
                Let's walk through a concrete example. Imagine you're building an AI assistant that needs to
                access your company's PostgreSQL database.
            </p>

            <h4>Without MCP: The Old Way</h4>

            <ol>
                <li>Write custom code to connect to PostgreSQL</li>
                <li>Implement authentication and security</li>
                <li>Create functions to query the database</li>
                <li>Format results for the AI model</li>
                <li>Handle errors and edge cases</li>
                <li>Maintain this code as your database schema evolves</li>
            </ol>

            <p>
                Now multiply this by every data source you want to connect. It's not scalable.
            </p>

            <h4>With MCP: The New Way</h4>

            <ol>
                <li>Install an existing PostgreSQL MCP server (already written, tested, and maintained)</li>
                <li>Configure connection credentials</li>
                <li>Start the MCP server</li>
                <li>Your AI assistant automatically discovers available tables and functions</li>
                <li>The AI can now query your database using natural language</li>
            </ol>

            <div class="image-container">
                <img src="../images/mcp-simplified-architecture.webp" alt="Simplified architecture"
                    style="width: 100%; height: 400px; object-fit: cover;" />
                <p class="image-caption">MCP dramatically simplifies integration architecture</p>
            </div>

            <p>
                The magic is in the standardization. The MCP client (your AI assistant) doesn't need to know
                anything about PostgreSQL. It just speaks MCP. The MCP server handles all database-specific logic.
            </p>

            <div class="code-block">
                # Install MCP server
                npm install @modelcontextprotocol/server-postgres

                # Configure and start
                mcp-server-postgres --connection-string "postgresql://..."

                # AI assistant automatically discovers:
                # - Available tables
                # - Table schemas
                # - Query capabilities
                # - No custom code required
            </div>

            <hr />

            <h2>The MCP Ecosystem</h2>

            <p>
                MCP's power comes from its growing ecosystem. Because it's an open standard, anyone can build
                MCP servers for any data source or tool.
            </p>

            <h3>Official MCP Servers</h3>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Server</th>
                        <th>Purpose</th>
                        <th>Use Cases</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Filesystem</strong></td>
                        <td>Read and write local files</td>
                        <td>Document analysis, code generation</td>
                    </tr>
                    <tr>
                        <td><strong>PostgreSQL</strong></td>
                        <td>Query and modify databases</td>
                        <td>Data analysis, reporting, ETL</td>
                    </tr>
                    <tr>
                        <td><strong>GitHub</strong></td>
                        <td>Repository management</td>
                        <td>Code review, issue tracking, PR automation</td>
                    </tr>
                    <tr>
                        <td><strong>Google Drive</strong></td>
                        <td>Access cloud documents</td>
                        <td>Document search, content extraction</td>
                    </tr>
                    <tr>
                        <td><strong>Slack</strong></td>
                        <td>Message and channel operations</td>
                        <td>Team communication, notifications</td>
                    </tr>
                </tbody>
            </table>

            <h3>Community MCP Servers</h3>

            <p>
                The community has created MCP servers for virtually every popular service:
            </p>

            <ul>
                <li>AWS (S3, Lambda, DynamoDB)</li>
                <li>Databases (MongoDB, MySQL, Redis)</li>
                <li>APIs (Stripe, Twilio, SendGrid)</li>
                <li>Development tools (Docker, Kubernetes, Terraform)</li>
                <li>Productivity tools (Notion, Jira, Trello)</li>
            </ul>

            <div class="image-container">
                <img src="../images/mcp-network-connectivity.webp"
                    alt="Network diagram showing interconnected MCP servers" />
                <p class="image-caption">MCP creates a network effect‚Äîeach new server makes the ecosystem more
                    valuable</p>
            </div>

            <p>
                You can browse available servers at the official MCP registry, or search GitHub for
                "mcp-server" to find community implementations.
            </p>

            <div class="info-box">
                <h4>üí° Building Your Own MCP Server</h4>
                <p>Need to connect to a proprietary system? Building an MCP server is straightforward. The
                    official SDK provides TypeScript and Python implementations. Most servers are under 200
                    lines of code.</p>
            </div>

            <hr />

            <h2>Real-World Use Cases</h2>

            <h3>Use Case 1: Intelligent Database Administration</h3>

            <p>
                A DevOps team uses Claude with an MCP server connected to their PostgreSQL monitoring database.
                Instead of writing SQL queries manually, they ask Claude natural language questions:
            </p>

            <ul>
                <li>"Which tables have grown the most in the last week?"</li>
                <li>"Show me slow queries from the past 24 hours"</li>
                <li>"Identify indexes that are never used"</li>
            </ul>

            <p>
                Claude queries the database through MCP, analyzes results, and provides actionable recommendations.
                The team saves hours of manual query writing and data analysis.
            </p>

            <h3>Use Case 2: Automated Code Review</h3>

            <p>
                A development team connects Claude to their GitHub repository via MCP. When a pull request is
                created:
            </p>

            <ol>
                <li>Claude automatically retrieves the PR diff through MCP</li>
                <li>Analyzes code changes for bugs, security issues, and style violations</li>
                <li>Reads relevant documentation from the codebase</li>
                <li>Posts detailed review comments back to GitHub through MCP</li>
            </ol>

            <p>
                The entire workflow is automated, consistent, and runs within seconds of PR creation.
            </p>

            <h3>Use Case 3: Customer Support Intelligence</h3>

            <p>
                A support team uses Claude with MCP servers for Slack, Zendesk, and their PostgreSQL customer
                database. When a customer issue comes in:
            </p>

            <ul>
                <li>Claude pulls customer history from the database</li>
                <li>Searches past support tickets for similar issues</li>
                <li>Identifies relevant documentation</li>
                <li>Drafts a personalized response with context from all sources</li>
                <li>Posts updates to Slack for team visibility</li>
            </ul>

            <div class="image-container">
                <img src="../images/mcp-team-collaboration.webp" alt="Team collaborating on customer support" />
                <p class="image-caption">MCP enables AI to work across multiple systems seamlessly</p>
            </div>

            <hr />

            <h2>Security and Governance</h2>

            <p>
                Connecting AI to your data raises valid security concerns. MCP addresses these through several
                mechanisms:
            </p>

            <h4>Principle of Least Privilege</h4>

            <p>
                Each MCP server runs with minimal permissions. A filesystem server can be restricted to specific
                directories. A database server can use read-only credentials. This limits potential damage from
                misuse or compromise.
            </p>

            <h4>Explicit Permission Model</h4>

            <p>
                MCP clients must explicitly request access to resources and tools. Users can review and approve
                these requests before granting access. This creates an audit trail of what AI can access.
            </p>

            <h4>Local Execution</h4>

            <p>
                MCP servers typically run on your infrastructure, not on external services. Your data never
                leaves your control. The AI model might run in the cloud, but the MCP server acts as a secure
                gateway that enforces your policies.
            </p>

            <ul>
                <li><strong>Credential management:</strong> MCP servers use standard credential stores
                    (environment variables, keychains, secret managers)</li>
                <li><strong>Network isolation:</strong> Servers can run behind firewalls with no inbound
                    access required</li>
                <li><strong>Audit logging:</strong> All MCP interactions can be logged for compliance and
                    security review</li>
                <li><strong>Rate limiting:</strong> Servers can implement rate limits to prevent abuse</li>
            </ul>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Security Best Practices</h4>
                <p>Always validate MCP server implementations before deployment. Review permissions carefully.
                    Use read-only credentials where possible. Monitor MCP server logs for unexpected behavior.
                    Remember: MCP is a powerful tool that requires responsible configuration.</p>
            </div>

            <hr />

            <h2>Comparing MCP to Alternatives</h2>

            <p>
                MCP isn't the first attempt at AI integration, but it learns from previous approaches:
            </p>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Strengths</th>
                        <th>Limitations</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Custom APIs</strong></td>
                        <td>Full control, optimized for use case</td>
                        <td>High development cost, no reusability</td>
                    </tr>
                    <tr>
                        <td><strong>Function Calling</strong></td>
                        <td>Native model support, simple</td>
                        <td>Requires custom code per integration</td>
                    </tr>
                    <tr>
                        <td><strong>RAG Systems</strong></td>
                        <td>Good for document search</td>
                        <td>Read-only, complex setup</td>
                    </tr>
                    <tr>
                        <td><strong>MCP</strong></td>
                        <td>Standardized, reusable, ecosystem</td>
                        <td>Requires MCP-compatible client</td>
                    </tr>
                </tbody>
            </table>

            <p>
                The key advantage of MCP is ecosystem leverage. Instead of building everything yourself, you
                benefit from community contributions. As more MCP servers are created, every MCP-compatible
                client becomes more powerful automatically.
            </p>

            <hr />

            <h2>Getting Started with MCP</h2>

            <p>
                Ready to experiment with MCP? Here's a practical starting path:
            </p>

            <h4>Step 1: Choose an MCP Client</h4>

            <p>
                Claude Desktop is the easiest starting point‚Äîit has built-in MCP support. You can also use:
            </p>

            <ul>
                <li>Claude Code (CLI tool for developers)</li>
                <li>Custom applications built with the MCP SDK</li>
                <li>IDEs with MCP extensions (VS Code, Cursor)</li>
            </ul>

            <h4>Step 2: Install an MCP Server</h4>

            <p>
                Start with the filesystem server‚Äîit's simple and immediately useful:
            </p>

            <div class="code-block">
                # Install the MCP filesystem server
                npm install -g @modelcontextprotocol/server-filesystem

                # Configure in your MCP client settings
                {
                "mcpServers": {
                "filesystem": {
                "command": "mcp-server-filesystem",
                "args": ["/path/to/your/documents"]
                }
                }
                }
            </div>

            <h4>Step 3: Test the Integration</h4>

            <p>
                Open your MCP client and try natural language requests:
            </p>

            <ul>
                <li>"What files are in my documents folder?"</li>
                <li>"Search for mentions of 'quarterly report' in my files"</li>
                <li>"Summarize the contents of project-notes.md"</li>
            </ul>

            <p>
                The AI now has contextual access to your files through MCP, without you writing any
                integration code.
            </p>

            <h4>Step 4: Expand Your Capabilities</h4>

            <p>
                Add more MCP servers as you identify needs:
            </p>

            <ul>
                <li>Database server for data analysis</li>
                <li>GitHub server for code repository access</li>
                <li>Slack server for team communication</li>
                <li>Custom server for your proprietary systems</li>
            </ul>

            <div class="image-container">
                <img src="../images/mcp-visual-workflow.webp" alt="Visual workflow showing MCP integration" />
                <p class="image-caption">MCP makes AI integration accessible to teams of all sizes</p>
            </div>

            <div class="info-box">
                <h4>üí° Start Small, Scale Gradually</h4>
                <p>Don't try to connect everything at once. Start with one valuable integration, prove the
                    value, then expand. This minimizes risk and helps your team build expertise gradually.</p>
            </div>

            <hr />

            <h2>Building Custom MCP Servers</h2>

            <p>
                Sometimes you need to connect to a system that doesn't have an existing MCP server. Building
                one is straightforward with the official SDK.
            </p>

            <h4>Basic MCP Server Structure (TypeScript)</h4>

            <div class="code-block">
                import { Server } from "@modelcontextprotocol/sdk/server/index.js";
                import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

                // Create server instance
                const server = new Server(
                {
                name: "my-custom-server",
                version: "1.0.0",
                },
                {
                capabilities: {
                resources: {},
                tools: {},
                },
                }
                );

                // Define a tool
                server.setRequestHandler("tools/call", async (request) => {
                if (request.params.name === "get_data") {
                const data = await fetchDataFromYourSystem();
                return { content: [{ type: "text", text: JSON.stringify(data) }] };
                }
                });

                // Start server
                const transport = new StdioServerTransport();
                await server.connect(transport);
            </div>

            <p>
                This basic pattern can be extended to connect to virtually any system. The MCP SDK handles
                protocol details, so you focus on your integration logic.
            </p>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Server Development Best Practices</h4>
                <p>Always validate inputs, handle errors gracefully, implement rate limiting, log operations
                    for debugging, and document your server's capabilities clearly. Remember that your server
                    is an AI-accessible gateway to your systems.</p>
            </div>

            <hr />

            <h2>The Future of MCP</h2>

            <p>
                MCP is still young, but its trajectory is clear. Here's what's emerging:
            </p>

            <h4>Standardization Across AI Platforms</h4>

            <p>
                More AI platforms are adding MCP support. As the standard gains adoption, integration becomes
                a one-time investment that works across all your AI tools.
            </p>

            <h4>Enterprise MCP Registries</h4>

            <p>
                Organizations are building internal registries of approved MCP servers. This creates
                consistency across teams while maintaining security and governance.
            </p>

            <h4>MCP-Native Applications</h4>

            <p>
                Applications designed from the ground up with MCP integration. Rather than bolting AI onto
                existing tools, new tools are being built where AI access is a first-class feature.
            </p>

            <h4>Cross-Organization MCP Networks</h4>

            <p>
                Imagine B2B integrations where your AI can securely access your partner's systems through
                MCP, with permissions and governance managed through the protocol itself.
            </p>

            <div class="image-container">
                <img src="../images/mcp-future-vision.webp" alt="Future technology vision" />
                <p class="image-caption">MCP is laying the foundation for truly connected AI systems</p>
            </div>

            <hr />

            <h2>Why MCP Matters Now</h2>

            <p>
                The AI integration problem is getting worse, not better. As AI becomes more capable, the
                pressure to connect it to real systems intensifies. Without a standard like MCP, we're heading
                toward a fragmented ecosystem of incompatible integrations.
            </p>

            <p>
                MCP provides a path forward:
            </p>

            <ul>
                <li><strong>For developers:</strong> Stop rebuilding the same integrations for each AI tool</li>
                <li><strong>For organizations:</strong> Gain control over AI access to sensitive systems</li>
                <li><strong>For the ecosystem:</strong> Enable innovation through shared infrastructure</li>
            </ul>

            <blockquote>
                The question isn't whether AI needs better integration‚Äîit's whether we'll solve it with
                standards or with chaos.
            </blockquote>

            <p>
                MCP represents the standards-based approach. It's open source, vendor-neutral, and designed
                for the long term. As the ecosystem matures, the organizations that adopt MCP early will have
                a significant advantage in AI capability and integration efficiency.
            </p>

            <hr />

            <h2>Further Reading and Resources</h2>

            <ul>
                <li>
                    <a href="https://modelcontextprotocol.io/" target="_blank">
                        Official MCP Documentation
                    </a> - Complete protocol specification and guides
                </li>
                <li>
                    <a href="https://github.com/modelcontextprotocol" target="_blank">
                        MCP GitHub Organization
                    </a> - Official SDKs and reference servers
                </li>
                <li>
                    <a href="https://glama.ai/mcp/servers" target="_blank">
                        MCP Server Registry
                    </a> - Searchable directory of available servers
                </li>
                <li>
                    <a href="https://anthropic.com/news/model-context-protocol" target="_blank">
                        Anthropic's MCP Announcement
                    </a> - Background and vision for the protocol
                </li>
            </ul>

            <hr />

            <h2>Final Thought</h2>

            <p>
                The Model Context Protocol isn't just another API standard‚Äîit's a fundamental shift in how
                we think about AI integration. By providing a universal language for AI assistants to interact
                with data and tools, MCP unlocks capabilities that were previously impractical or impossible.
            </p>

            <p>
                The organizations that recognize this early and invest in MCP-based integration will find
                themselves with a significant competitive advantage. Not because they have better AI models,
                but because their AI can actually access and use the data and tools that matter.
            </p>

            <blockquote>
                Standards don't just make things easier‚Äîthey make things possible.
            </blockquote>

            <div class="image-container">
                <img src="../images/mcp-connected-systems.webp" alt="Connected future" />
                <p class="image-caption">MCP is building bridges between AI capabilities and real-world systems
                </p>
            </div>
        </article>

        <footer class="post-footer">
            <a href="../index.html" class="back-link"> Back to Blog</a>
            <div class="share-section">
                <p>Found this useful? Share it with your network.</p>
                <div class="share-buttons">
                    <button class="share-btn" id="native-share-btn" style="display: none;">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
                        </svg>
                        Share
                    </button>
                    <a href="#" class="share-btn" id="linkedin-share">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                        </svg>
                        LinkedIn
                    </a>
                    <a href="#" class="share-btn" id="twitter-share">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                        Twitter
                    </a>
                    <a href="#" class="share-btn" id="email-share">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                        </svg>
                        Email
                    </a>
                    <button class="share-btn" id="copy-link">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                        </svg>
                        <span id="copy-text">Copy Link</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <!-- SCRIPT FOR PROGRESS BAR -->
    <script>
        const progressBar = document.getElementById("reading-progress");

        window.addEventListener("scroll", () => {
            const scrollTop = window.scrollY;
            const docHeight =
                document.documentElement.scrollHeight -
                document.documentElement.clientHeight;

            const scrollPercent = (scrollTop / docHeight) * 100;
            progressBar.style.width = scrollPercent + "%";
        });
    </script>

    <!-- SCRIPT FOR SHARE BUTTONS -->
    <script>
        const pageUrl = window.location.href;
        const pageTitle = document.title;

        // Show native share button if Web Share API is supported
        if (navigator.share) {
            document.getElementById('native-share-btn').style.display = 'inline-flex';

            document.getElementById('native-share-btn').addEventListener('click', async () => {
                try {
                    await navigator.share({
                        title: pageTitle,
                        url: pageUrl
                    });
                } catch (err) {
                    // User cancelled or share failed
                    console.log('Share cancelled');
                }
            });
        }

        // LinkedIn share
        document.getElementById('linkedin-share').addEventListener('click', (e) => {
            e.preventDefault();
            const linkedinUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(pageUrl)}`;
            window.open(linkedinUrl, '_blank', 'width=600,height=400');
        });

        // Twitter share
        document.getElementById('twitter-share').addEventListener('click', (e) => {
            e.preventDefault();
            const twitterUrl = `https://twitter.com/intent/tweet?url=${encodeURIComponent(pageUrl)}&text=${encodeURIComponent(pageTitle)}`;
            window.open(twitterUrl, '_blank', 'width=600,height=400');
        });

        // Email share
        document.getElementById('email-share').addEventListener('click', (e) => {
            e.preventDefault();
            const subject = encodeURIComponent(pageTitle);
            const body = encodeURIComponent(`I thought you might find this interesting:\n\n${pageUrl}`);
            window.location.href = `mailto:?subject=${subject}&body=${body}`;
        });

        // Copy link
        document.getElementById('copy-link').addEventListener('click', async () => {
            const copyBtn = document.getElementById('copy-link');
            const copyText = document.getElementById('copy-text');

            try {
                await navigator.clipboard.writeText(pageUrl);
                copyBtn.classList.add('copied');
                copyText.textContent = 'Copied!';

                setTimeout(() => {
                    copyBtn.classList.remove('copied');
                    copyText.textContent = 'Copy Link';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = pageUrl;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);

                copyBtn.classList.add('copied');
                copyText.textContent = 'Copied!';

                setTimeout(() => {
                    copyBtn.classList.remove('copied');
                    copyText.textContent = 'Copy Link';
                }, 2000);
            }
        });
    </script>

</body>

</html>